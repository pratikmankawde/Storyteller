## Code Quality Standards

 ### Architecture & Design Patterns
 - Follow **Clean Architecture** principles with clear separation between domain/data/ui layers
 - Use **MVVM pattern** for UI components (ViewModel + StateFlow/LiveData)
 - Apply **Strategy Pattern** for swappable implementations (e.g., LlmModel interface with multiple implementations)
 - Use **Factory Pattern** for object creation when multiple implementations exist
 - Implement **Repository Pattern** for data access abstraction
 - Apply **Facade Pattern** for complex subsystem interfaces (e.g., LlmService)

 ### Modularity & Organization
 - Keep functions small and focused (single responsibility principle)
 - Extract reusable logic into dedicated utility classes or extension functions
 - Organize code in dedicated directories by feature/layer (e.g., `ai/llm/models/`, `ai/llm/prompts/`)
 - Avoid God classes - split large classes (>500 lines) into smaller, cohesive units
 - Use composition over inheritance where appropriate

 ### Kotlin Best Practices
 - Use **proper coroutine scopes** (`viewModelScope`, `lifecycleScope`) - never use `GlobalScope`
 - Handle **cancellation gracefully** with try-catch for `CancellationException`
 - Use `Flow` and `StateFlow` for reactive data streams
 - Mark async operations as `suspend` functions
 - Use `sealed classes` for state management and error handling
 - Leverage Kotlin's null safety features (avoid `!!` operator)
 - Use data classes for DTOs and value objects

 ### Performance & Threading
 - Keep UI responsive - **never block the main thread**
 - Use `Dispatchers.IO` for I/O operations (file, database, network)
 - Use `Dispatchers.Default` for CPU-intensive work (LLM inference, parsing)
 - Use `withContext` to switch dispatchers within suspend functions
 - Implement proper timeout handling for long-running operations

 ### Error Handling & Logging
 - Use custom exception hierarchy (extend `AppException` with specific error types)
 - Provide user-friendly error messages separate from technical logs
 - Log with appropriate levels using `AppLogger` (d/i/w/e)
 - Include context in error messages (operation name, input parameters)
 - Implement graceful degradation with fallbacks where appropriate

 ### Code Documentation
 - Add KDoc comments for public APIs, interfaces, and complex logic
 - Document **why** decisions were made, not just **what** the code does
 - Include usage examples in documentation for non-trivial APIs
 - Mark deprecated code with `@Deprecated` and migration path

 ### Testing & Quality
 - Write unit tests for business logic and data transformations
 - Ensure tests can run in parallel (no shared mutable state)
 - Build must complete with **zero errors and zero warnings**
 - Follow existing code style and naming conventions

 Apply these principles consistently across all code changes, refactoring, and new feature implementations.
